"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _jsonRefs = require("json-refs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const CFTemplate = {
  schema: (() => {
    const CfnTag = params => {
      const key = params.fn || `Fn::${params.name}`;
      return new _jsYaml.default.Type(`!${params.name}`, {
        kind: params.kind,
        construct: data => ({
          [key]: data
        }),
        predicate: obj => Object.prototype.toString.call(obj) === '[object Object]' && Object.keys(obj).length === 1 && Object.keys(obj)[0] === key,
        represent: obj => obj[key]
      });
    };

    const tags = [{
      name: 'And',
      kind: 'sequence'
    }, {
      name: 'Base64',
      kind: 'scalar'
    }, {
      name: 'Equals',
      kind: 'sequence'
    }, {
      name: 'FindInMap',
      kind: 'sequence'
    }, {
      name: 'GetAtt',
      kind: 'sequence'
    }, {
      name: 'GetAtt',
      kind: 'scalar'
    }, {
      name: 'GetAZs',
      kind: 'scalar'
    }, {
      name: 'If',
      kind: 'sequence'
    }, {
      name: 'ImportValue',
      kind: 'scalar'
    }, {
      name: 'Join',
      kind: 'sequence'
    }, {
      name: 'Not',
      kind: 'sequence'
    }, {
      name: 'Or',
      kind: 'sequence'
    }, {
      name: 'Ref',
      kind: 'scalar',
      fn: 'Ref'
    }, {
      name: 'Select',
      kind: 'sequence'
    }, {
      name: 'Split',
      kind: 'sequence'
    }, {
      name: 'Sub',
      kind: 'sequence'
    }, {
      name: 'Sub',
      kind: 'scalar'
    }].map(obj => CfnTag(obj));
    return _jsYaml.default.Schema.create(tags);
  })(),
  build: async params => {
    const tmpfiles = [];
    const indexYaml = `${params.dir}/${params.entry}`;

    const root = _jsYaml.default.safeLoad(_fs.default.readFileSync(indexYaml, 'utf8').toString(), {
      schema: CFTemplate.schema
    });

    const options = {
      filter: ['relative'],
      loaderOptions: {
        processContent: (res, cb) => cb(null, _jsYaml.default.safeLoad(res.text, {
          schema: CFTemplate.schema
        }))
      },
      refPreProcessor: (ref, paths) => {
        if (!ref.$ref.startsWith('.')) {
          return ref;
        }

        const dirname = _path.default.parse(ref.$ref.substr(1)).name;

        if (!_fs.default.existsSync(`${params.dir}/${dirname}`)) {
          return ref;
        }

        if (_fs.default.existsSync(`${params.dir}/.${dirname}.yml`)) {
          throw new Error(`.${dirname}.yml already exists. Can not merge files under ${dirname}.`);
        }

        const mergedData = _fs.default.readdirSync(`${params.dir}/${dirname}`).map(file => _fs.default.readFileSync(`${params.dir}/${dirname}/${file}`, 'utf8')).join('\n');

        _fs.default.writeFileSync(`${params.dir}/.${dirname}.yml`, mergedData);

        ref.$ref = `.${dirname}.yml`;
        tmpfiles.push(`${params.dir}/.${dirname}.yml`);
        return ref;
      },
      location: indexYaml
    };

    try {
      const result = await (0, _jsonRefs.resolveRefs)(root, options);
      const errors = Object.keys(result.refs).map(key => {
        const data = result.refs[key];

        if (data.missing) {
          return data.error;
        }

        return '';
      }).filter(data => data);

      if (errors.length) {
        throw new Error(errors.join('\n'));
      }

      const data = _jsYaml.default.safeDump(result.resolved, {
        schema: CFTemplate.schema
      });

      return data.replace(/!<(.+?)>/g, '$1');
    } finally {
      tmpfiles.forEach(file => _fs.default.unlinkSync(file));
    }
  }
};
var _default = CFTemplate;
exports.default = _default;